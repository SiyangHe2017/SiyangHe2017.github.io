<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Mock学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/11/16/Mock%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time datetime="2023-11-16T09:04:34.000Z" itemprop="datePublished">2023-11-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/11/16/Mock%E5%AD%A6%E4%B9%A0/">Mock学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><p>@Runwith是什么意思？<br>@RunWith是Java 中 JUnit 测试框架的一个注解。它用于指定一个测试运行器（Test Runner），这个测试运行器负责执行测试用例并生成测试结果。在 JUnit 4 中，@RunWith 常用于指定不同类型的测试运行器，比如用于单元测试、参数化测试或者集成测试。<br>例如，在使用 Spring 框架进行单元测试时，你可能会看到这样的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTestClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 测试方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，@RunWith(SpringJUnit4ClassRunner.class)告诉JUnit使用Spring的测试运行器来执行这个类中的测试方法。这使得测试类可以利用Spring框架的功能，比如依赖注入和事务管理。</p>
</li>
<li><p>@PrepareForTest是什么意思？<br>@PrepareForTest是由Mockito的一个扩展库PowerMock提供的注解。PowerMock是一个用于扩展Mockito功能的库，它允许你模拟构造函数、静态方法和私有方法等，这些通常是 Mockito无法直接模拟的。<br>使用@PrepareForTest注解是为了指示PowerMock准备某些类以便进行测试，这些类将会涉及到静态方法的模拟、私有方法的模拟、final 方法的模拟、构造函数的模拟，或者是对系统类的模拟等情况。<br>当你使用@PrepareForTest时，你需要传递一个类或类的数组给这个注解，告诉PowerMock 需要重写和准备这些类中的静态和私有方法，以便可以对它们进行模拟。</p>
</li>
<li><p>在Mockito测试框架中，@InjectMock和@Mock分别代表什么意思？<br>可以从Mock和InjectMock的英文意思了解，mock的意思是模仿，inject的意思是注射/注入。<br>因此，@Mock会创建一个mock对象。这个对象会模仿真实对象的行为，但实际上并不执行真正的逻辑。@InjectMock会创建一个实例，并自动将标记为 @Mock 的mock对象注入到该实例中。</p>
<table>
<thead>
<tr>
<th>@Mock</th>
<th align="center">@InjectMock</th>
</tr>
</thead>
<tbody><tr>
<td>@Mock creates a mock</td>
<td align="center">@InjectMocks creates an instance of the class and injects the mocks that are created with the @Mock annotations into this instance</td>
</tr>
<tr>
<td>@Mock is used to create mocks that are needed to support the testing of the class to be tested</td>
<td align="center">@InjectMocks is used to create class instances that need to be tested in the test class.</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Book <span class="title">getBookById</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Normally, this method might fetch a book from the database.</span></span><br><span class="line">        <span class="comment">// ... (some logic)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Book(id, <span class="string">&quot;Sample Book&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookService bookService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderService</span><span class="params">(BookService bookService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bookService = bookService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">orderBook</span><span class="params">(String bookId)</span> </span>&#123;</span><br><span class="line">        Book book = bookService.getBookById(bookId);</span><br><span class="line">        <span class="comment">// ... (some logic to order the book)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Ordered: &quot;</span> + book.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举个例子: 假设你正在开发一个在线书店。在书店中，有一个 BookService 用来处理与书相关的各种事务。此外，还有一个 OrderService，当用户想购买一本书时，它会与 BookService 交互。<br>现在，你想为 OrderService 编写一个单元测试，但不想实际调用 BookService（也许因为它涉及到数据库调用或其他外部服务）。这就是 @Mock 和 @InjectMocks 登场的地方。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(MockitoJUnitRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> BookService bookService;  <span class="comment">// This creates a mock (fake) version of BookService</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@InjectMocks</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;  <span class="comment">// This tells Mockito to use the mock BookService in OrderService</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOrderBook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Setting up the mock behavior</span></span><br><span class="line">        when(bookService.getBookById(<span class="string">&quot;123&quot;</span>)).thenReturn(<span class="keyword">new</span> Book(<span class="string">&quot;123&quot;</span>, <span class="string">&quot;Mocked Book&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test the orderBook method</span></span><br><span class="line">        String result = orderService.orderBook(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        assertEquals(<span class="string">&quot;Ordered: Mocked Book&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中:<br>@Mock 用于创建一个模拟的 BookService。这意味着当你调用这个模拟的 bookService.getBookById 时，你可以设定它返回你想要的任何内容（在这个例子中，我们让它返回一个叫做 “Mocked Book” 的书）。<br>@InjectMocks 用于在 OrderService 中自动注入模拟的 BookService。这意味着当你在测试中调用 orderService.orderBook 时，它实际上使用的是模拟的 BookService，而不是真实的服务。<br>总的来说，<strong>在Mockito测试框架中, @Mock 用于创建模拟对象，而 @InjectMocks 用于将这些模拟对象自动注入到要测试的类中。</strong></p>
</li>
<li><p>mockito.verify()语法是什么意思？<br>a. 基本用法：确认模拟对象的某个方法是否被调用。<code>Mockito.verify(mockObject).someMethod();</code><br>b. 确认方法被调用的次数。<br><code>Mockito.verify(mockObject, Mockito.times(2)).someMethod();</code><br>c. 确认方法从未被调用。<br><code>javaMockito.verify(mockObject, Mockito.never()).someMethod();</code></p>
</li>
<li><p>Junit中的<code>@Before</code>是什么意思？<br><code>@Before</code> 是JUnit 4中的一个注解，它用于标记一个在每个测试方法之前自动执行的方法。这个注解通常用于设置测试环境，例如初始化共享资源、配置模拟对象或设置测试数据。使用 <code>@Before</code> 确保在运行任何测试方法之前，所需的初始化代码都已执行。<br>例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SomeResource resource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化代码</span></span><br><span class="line">        resource = <span class="keyword">new</span> SomeResource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用 resource</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用 resource</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，setUp 方法被标记为 <code>@Before</code>，意味着它会在 testMethod1 和 testMethod2 执行之前各运行一次。</p>
</li>
<li><p>注解<code>@Mock</code>它实际上执行了什么操作？<br><code>@Mock</code>注解在 Mockito 框架中的作用是声明一个字段为模拟（mock）对象。当使用这个注解时，它通知 Mockito 框架自动创建并注入一个模拟实例到被注解的字段。这个过程需要通过调用 MockitoAnnotations.initMocks(this) 或使用其他类似机制来激活。<br>下面是 @Mock 注解实际上执行的主要操作：<br>a. 自动创建模拟实例：当你在一个字段上使用 @Mock 注解，并且在测试的设置阶段调用 MockitoAnnotations.initMocks(this) 或使用类似机制，Mockito 会自动创建该字段类型的模拟实例。这意味着你不需要手动调用 mock(MyClass.class) 来创建一个模拟对象；注解和初始化方法会替你完成这个工作。<strong>Using runner lets you save a little bit of coding (no need for @Before method)。在有些情况下，比如如果你使用了@RunWith(PowerMockRunner.class), 你不必再调用MockitoAnnotations.initMocks(this)。</strong><br>b. 初始化测试类中的模拟对象：在测试类中，每个用 @Mock 注解的字段在测试开始前都会被初始化为相应类型的模拟对象。这是通过在测试类的构造方法、@Before 方法（JUnit 4），或者通过使用特定的测试运行器或扩展（如 JUnit 5 的 @ExtendWith(MockitoExtension.class)）完成的。<br>c. 提供默认行为：创建的模拟对象具有 Mockito 的默认行为。例如，对于非空返回类型的方法，模拟对象默认返回零值（如 0、false、null 等）。你可以通过 stubbing（桩设定）来改变这些方法的行为。<br>d. 允许桩设定和验证：一旦模拟对象被创建，你可以使用 Mockito 的 API 对这些对象进行桩设定（stubbing）和行为验证。例如，你可以指定当特定方法被调用时返回特定的值，或者验证特定方法是否被调用了特定次数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> MyService myService; <span class="comment">// Mockito 自动创建 MyService 类的模拟实例</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MockitoAnnotations.initMocks(<span class="keyword">this</span>); <span class="comment">// 初始化 @Mock 注解的字段</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用模拟对象进行测试...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，myService 字段被标记为 @Mock，Mockito 负责创建 MyService 类的一个模拟实例。这个模拟实例将在 setUp 方法中被初始化，该方法在每个测试方法之前执行。</p>
</li>
<li><p>doReturn()和doAnswer()有什么区别呢？<br>doReturn() 主要用于直接指定模拟方法的返回值，适用于简单的场景，比如当你只需要模拟一个方法返回特定的值时。<br>doAnswer() 用于实现更复杂的行为。它允许你通过 Answer 接口实现自定义逻辑，这意味着你可以在方法被调用时执行任何 Java 代码。这使得 doAnswer() 比 doReturn() 更灵活，特别是在需要访问调用方法时传入的参数或需要根据这些参数动态决定返回值的场景中。<br>doReturn语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doReturn(返回值).when(模拟对象).方法调用;</span><br></pre></td></tr></table></figure>
<p>doAnswer语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">doAnswer(<span class="keyword">new</span> Answer&lt;TypeOfReturnValue&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TypeOfReturnValue <span class="title">answer</span><span class="params">(InvocationOnMock invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 自定义行为的逻辑</span></span><br><span class="line">        <span class="comment">// 可以使用 invocation.getArgument(index) 来获取方法调用的参数</span></span><br><span class="line">        <span class="keyword">return</span> someValue; <span class="comment">// 根据需要返回相应的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).when(mockObject).methodToBeMocked(argumentsIfAny);</span><br></pre></td></tr></table></figure>
<p>TypeOfReturnValue 是模拟方法预期返回的类型。如果模拟的方法返回 void，则可以使用 <code>Answer&lt;Void&gt;</code>。<br><code>methodToBeMocked(argumentsIfAny)</code>是需要模拟的方法和其参数。如果方法没有参数或者你不关心参数值，可以使用 any() 匹配器。<br>这里是一个更加简捷的lamba8版本</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">doAnswer(invocation -&gt; &#123;</span><br><span class="line">    <span class="comment">// 自定义行为的逻辑</span></span><br><span class="line">    <span class="keyword">return</span> someValue;</span><br><span class="line">&#125;).when(mockObject).methodToBeMocked(argumentsIfAny);</span><br></pre></td></tr></table></figure>
<p>假设你有一个 CalculatorService 类，它有一个 add 方法，你想模拟这个方法的行为，使其返回两个输入参数的乘积而不是和:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CalculatorService mockCalculator = mock(CalculatorService.class);</span><br><span class="line">doAnswer(invocation -&gt; &#123;</span><br><span class="line">    <span class="keyword">int</span> arg1 = invocation.getArgument(<span class="number">0</span>); <span class="comment">// 获取第一个参数</span></span><br><span class="line">    <span class="keyword">int</span> arg2 = invocation.getArgument(<span class="number">1</span>); <span class="comment">// 获取第二个参数</span></span><br><span class="line">    <span class="keyword">return</span> arg1 * arg2; <span class="comment">// 返回参数的乘积</span></span><br><span class="line">&#125;).when(mockCalculator).add(anyInt(), anyInt());</span><br><span class="line"><span class="comment">// 使用模拟对象</span></span><br><span class="line"><span class="keyword">int</span> result = mockCalculator.add(<span class="number">5</span>, <span class="number">10</span>); <span class="comment">// 结果将是 50</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，doAnswer(…) 用于模拟 add 方法，使其返回两个参数的乘积。通过 <code>invocation.getArgument(index)</code>方法，可以访问到方法调用时传递的参数。</p>
</li>
<li><p><code>@Mock</code> 和<code>@Spy</code>有什么区别？<br>在 Mockito 框架中，<code>@Mock</code> 和 <code>@Spy</code> 注解都用于创建模拟（mock）对象，但它们在行为上有显著的区别。<br>在<code>@Mock</code>中<br>完全模拟：使用 <code>@Mock</code> 注解创建的对象是完全的模拟（mock）。这意味着所有的方法调用都不会执行实际的代码，除非你为它们定义了特定的行为（如使用 <code>when(...).thenReturn(...)</code>）。<br>默认行为：对于没有显式定义行为的方法，模拟对象会返回默认值（如 <code>null</code>、<code>0</code>、<code>false</code> 等），而不是执行任何实际逻辑。<br>适用场景：当你不关心或不需要对象的实际实现，只想测试与该对象的交互时，使用 <code>@Mock</code> 是合适的。<br>在<code>@Spy</code>中<br>部分模拟：使用 <code>@Spy</code> 注解创建的对象是部分模拟（spy）。这意味着除非你为特定方法定义了模拟行为，否则调用对象的方法将执行实际的代码。<br>真实行为：对于没有显式定义行为的方法，spy 对象会执行实际的方法代码。你可以为某些方法定义模拟行为，而其他方法则保持它们的原始行为。<br>适用场景：当你需要保留对象的大部分真实行为，但同时需要覆盖或模拟某些方法时，使用 <code>@Spy</code> 是合适的。</p>
</li>
<li><p>一般情况下，建议使用doReturn()when()而不是使用when()thenReturn()。</p>
</li>
<li><p>when().thenReturn(“”,””).thenThrow()是什么意思？<br>在 Mockito 中，<code>when().thenReturn(&quot;&quot;,&quot;&quot;).thenThrow()</code> 是一种链式调用，用于设置模拟对象在不同调用下的行为。这种语法允许你为同一个方法调用定义一系列不同的行为，根据它被调用的次数。<br><code>when(mockObject.someMethod())</code>：指定我们要模拟的方法调用。这里 <code>mockObject</code> 是模拟对象，而 <code>someMethod()</code> 是我们想要模拟的方法。<br><code>thenReturn(&quot;第一次返回值&quot;, &quot;第二次返回值&quot;)</code>：定义当 <code>someMethod()</code> 方法被调用时的返回值。在第一次调用时，它将返回 <code>&quot;第一次返回值&quot;</code>，在第二次调用时返回 <code>&quot;第二次返回值&quot;</code>。<br><code>thenThrow(new ExceptionType())</code>：定义当 <code>someMethod()</code> 方法第三次被调用时抛出指定类型的异常。<br>假设有一个方法 getString，你想要模拟这个方法的行为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实际逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">MyService mockService = mock(MyService.class);</span><br><span class="line">when(mockService.getString())</span><br><span class="line">    .thenReturn(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>)</span><br><span class="line">    .thenThrow(<span class="keyword">new</span> RuntimeException(<span class="string">&quot;No more calls allowed&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>在这个示例中，当 getString 方法被调用：<br>第一次，它将返回 “Hello”。<br>第二次，它将返回 “World”。<br>第三次及之后的调用，它将抛出一个 RuntimeException。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2023/11/16/Mock%E5%AD%A6%E4%B9%A0/" data-id="clp1yj7lq0004mpwk3toac37a" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2023-10-13总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/10/13/2023-10-13%E6%80%BB%E7%BB%93/" class="article-date">
  <time datetime="2023-10-13T12:10:59.000Z" itemprop="datePublished">2023-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/10/13/2023-10-13%E6%80%BB%E7%BB%93/">2023-10-13总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><p>在 IntelliJ IDEA 中，Maven Home Path、User Setting File 和 Local Repository有什么区别？<br><img src="/2023/10/13/2023-10-13%E6%80%BB%E7%BB%93/maven_setting.png" alt="maven_setting"><br>1）Maven Home Path 是 Maven 安装的位置，它包含了 Maven 的二进制文件、库和其他的必要资源。该路径应该指向 Maven 安装的根目录，而不是 bin 目录。Maven Home Path 是 Maven 运行所需的基本配置，它告诉 IntelliJ IDEA 在哪里可以找到 Maven 的执行文件。<br>2）User Setting File:<br>User Setting File 是一个 XML 文件，通常名为 settings.xml，它包含了 Maven 的配置信息。这个文件通常包含了代理设置、镜像仓库配置、服务器认证信息等。通常情况下，这个文件位于 Maven 安装目录下的 conf 目录中，或者在用户的 home 目录中的 .m2 目录下。<br>3）Local Repository:<br>Local Repository 是本地的 Maven 仓库，它存储了所有的项目依赖和插件。当 Maven 需要一个特定的库或插件时，它会首先在本地仓库中查找。<strong>Local Repository 是 Maven 下载和存储项目依赖的地方，它允许 Maven 在构建项目时不必每次都从远程仓库下载依赖。</strong>如果在本地仓库中找不到所需的库或插件，Maven 会尝试从中央仓库或配置的其他远程仓库下载。默认情况下，本地仓库位于用户的 home 目录中的 .m2/repository 目录下。</p>
</li>
<li><p>如上图所示，intellij maven设置里面的 use settings from .mvn/maven.config是什么意思？<br>在 IntelliJ IDEA 中，Maven 设置中的 “Use settings from .mvn/maven-config” 选项允许你指定一个特定的配置文件，该文件应包含 Maven 构建过程中所需的自定义设置和选项。这个配置文件通常位于你的项目目录中的 .mvn 文件夹内，并且命名为 maven.config。<br>下面是一些详细的解释：<br>mvn文件夹：mvn文件夹是一个可选的、位于项目根目录的文件夹，它可以包含一个或多个 Maven 配置文件。这个文件夹使得你可以为特定的 Maven 项目提供自定义的配置，而不是依赖于全局或用户级别的 Maven 配置。<br>maven.config 文件：maven.config 文件是一个简单的文本文件，它可以包含一系列的命令行选项，每个选项占一行。这些选项在执行 Maven 命令时将被使用，就好像它们是在命令行上指定的一样。<br>这个选项的一个常见用例是，如果你有一些特定的 Maven 插件或其他配置，它们应该只对当前项目有效，而不应该影响到其他 Maven 项目，那么你就可以使用 .mvn/maven.config 文件来指定这些设置。<br>通过启用 “Use settings from .mvn/maven.config” 选项，你告诉 IntelliJ IDEA 在处理 Maven 构建时应该考虑这个文件中的设置。<br>例如，你的 maven.config 文件可能包含以下内容，以指定一个特定的 Maven 插件版本和一些自定义的构建选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-P profile-name</span><br><span class="line">-DskipTests</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="3">
<li><p>在 IntelliJ IDEA 中，当你配置 Maven 时，会看到 “Bundled (Maven 3)” 和 “Use Maven Wrapper” 两个选项。这两个选项有什么区别？<br><img src="/2023/10/13/2023-10-13%E6%80%BB%E7%BB%93/maven_setting_2.png" alt="maven_setting"><br>1）Bundled (Maven 3)：”Bundled (Maven 3)” 意味着使用 IntelliJ IDEA 自带的 Maven 版本。这是一个内置于 IntelliJ IDEA 中的 Maven 版本，通常是 Maven 3 的一个版本。选择此选项意味着你不需要在本地机器上单独安装 Maven，因为 IntelliJ IDEA 已经为你提供了一个 Maven 版本。这个选项对于初学者和那些不想在自己的机器上管理 Maven 安装的用户来说是一个好选择。<br>2）Use Maven Wrapper：Maven Wrapper 是一个为 Maven 项目提供了一个可携带的构建系统的工具。通过使用 Maven Wrapper，你可以确保所有的构建都使用相同版本的 Maven，无论在哪个机器上执行构建。当你选择 “Use Maven Wrapper” 时，你的项目将使用一个名为 mvnw 的脚本来运行 Maven，而不是使用系统路径中的 mvn 命令。<br>Maven Wrapper 脚本会检查是否已经下载了正确版本的 Maven，如果没有，它会从网上下载正确版本的 Maven 并在本地缓存，然后使用它来执行构建。这个选项对于团队工作和确保构建一致性非常有用，尤其是当不同的机器上可能有不同版本的 Maven时。</p>
</li>
<li><p>JAVA_HOME环境变量和Path环境变量有什么区别？<br>1）JAVA_HOME 环境变量：<br>JAVA_HOME 环境变量通常用于指定 JDK 的安装目录。它是许多 Java 应用和系统工具识别 JDK 安装位置的方式。例如，一些 Java 应用服务器和开发工具可能需要 JAVA_HOME 环境变量来找到 JDK。<br>2）Path 环境变量：<br>Path 环境变量是操作系统用来查找可执行文件的目录列表。当你在命令行中输入一个命令时，操作系统会在 Path 环境变量指定的目录列表中查找该命令的可执行文件。通过将 JDK 的 bin 目录添加到 Path 环境变量中，你可以确保操作系统能够找到 Java 编译器 (javac) 和 Java 运行时 (java) 等基本的 Java 命令。<br>当你安装JDK时，通常需要同时设置JAVA_HOME和Path环境变量，以确保：其他应用能通过 JAVA_HOME找到JDK。你能在命令行中直接运行 Java 相关的命令，如java和javac，而无需指定它们的完整路径。</p>
</li>
<li><p>程序运行时出现”this is incompatible with sql_mode=only_full_group”是什么原因？<br>出现错误 “this is incompatible with sql_mode=only_full_group_by” 通常是因为 MySQL 服务器配置的 sql_mode 设置中包含了 ONLY_FULL_GROUP_BY，而你的查询没有遵守该模式的要求。ONLY_FULL_GROUP_BY 模式的目的是遵守 SQL 的标准规则，确保 GROUP BY 子句中列出的所有列都出现在选择列表中，或者与聚合函数一起使用。<br>1）可以通过<code>SELECT @@sql_mode</code>查询当前会话的sql_mode模式。<br>2）ONLY_FULL_GROUP_BY 是 MySQL 的一个 sql_mode 设置，它强制要求在使用 GROUP BY 语句时，所有在 SELECT 子句中列出的非聚合列必须在 GROUP BY 子句中明确指定。这样做是为了保证结果的确定性，避免返回意外或不确定的结果。<br>下面通过两个例子来解释这个模式的作用和意义。<br>例子1: 符合 ONLY_FULL_GROUP_BY 规则的查询<br>假设我们有一个名为 sales 的表，它有两个列 region 和 amount。我们想知道每个区域的销售总额。以下查询符合 ONLY_FULL_GROUP_BY 规则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT region, SUM(amount)</span><br><span class="line">FROM sales</span><br><span class="line">GROUP BY region;</span><br></pre></td></tr></table></figure>
<p>在这个查询中，我们在 SELECT 子句中列出了 region 列，并在 GROUP BY 子句中明确指定了 region 列。这符合 ONLY_FULL_GROUP_BY 规则。<br>例子2: 不符合 ONLY_FULL_GROUP_BY 规则的查询</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT region, amount</span><br><span class="line">FROM sales</span><br><span class="line">GROUP BY region;</span><br></pre></td></tr></table></figure>
<p>在这个查询中，我们在 SELECT 子句中列出了 region 和 amount 列，但在 GROUP BY 子句中只指定了 region 列。由于 amount 列没有在 GROUP BY 子句中列出，也没有与任何聚合函数一起使用，这个查询不符合 ONLY_FULL_GROUP_BY 规则，如果 ONLY_FULL_GROUP_BY 模式是启用的，MySQL 会返回一个错误。<br>这个模式的目的是确保每个 GROUP BY 查询的结果都是确定的和可重复的，避免因为遗漏 GROUP BY 中的列而导致不确定的结果。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2023/10/13/2023-10-13%E6%80%BB%E7%BB%93/" data-id="clp1yj7lo0002mpwk80ijd7vv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-springboot简介" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/12/springboot%E7%AE%80%E4%BB%8B/" class="article-date">
  <time datetime="2021-05-12T01:52:56.000Z" itemprop="datePublished">2021-05-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/12/springboot%E7%AE%80%E4%BB%8B/">springboot简介</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>用Spring Boot构建一个简单的web项目<br><a target="_blank" rel="noopener" href="http://www.ityouknow.com/springboot/2016/01/06/spring-boot-quick-start.html">通俗的说</a>，就是Spring Boot其实不是什么新的框架，它默认配置了许多框架的使用方式，就像Maven整合了许多的Jar包，Spring Boot整合了许多框架。</p>
<p>举个<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903841972879373">例子</a>来说明，平时我们通过 <code>Spring</code>和<code>Spring MVC</code> 搭建一个<code>helloword</code>的 Web 应用，需要做以下工作：<br>1.配置 pom.xml 添加 <code>Spring</code>、<code>Spring MVC</code>框架的依赖，同时还需要考虑这些不同的框架的不同版本是否存在不兼容的问题。<br>2.配置 Web.xml，加载 Spring、Spring MVC。<br>3.配置 Spring 。<br>4.配置 Spring MVC。<br>5.编写业务逻辑代码。</p>
<p>而使用 Spring Boot 搭建的话，需要做以下工作:<br>1.配置 pom.xml 继承 Spring Boot 的 <code>pom.xml</code>，添加 Web 起步依赖。<br>2.创建启动引导类。<br>3.编写业务逻辑代码。</p>
<h6 id="Spring-Boot父级依赖-spring-boot-starter-parent"><a href="#Spring-Boot父级依赖-spring-boot-starter-parent" class="headerlink" title="Spring Boot父级依赖(spring-boot-starter-parent)"></a>Spring Boot父级依赖(spring-boot-starter-parent)</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>spring-boot-starter-parent是用来干什么的？<br>根据<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/43305016/what-does-spring-boot-starter-parent-exactly-do-in-pom-file">stackoverflow</a>上面的说明:<br>The “spring-boot-starter-parent” is a special starter that provides useful Maven defaults i.e it adds all the required jars and other things automatically. It also provides a dependency-management section so that you can omit version tags for dependencies you are using in pom.xml.<br>用中文来说就是spring-boot-starter-parent是一个特殊的starter，它用来提供相关的Maven默认依赖以及一些其他的东西，使用它之后，常用的包依赖可以省去version标签。</p>
<h6 id="Spring-Boot起步依赖-spring-boot-starter-xxx"><a href="#Spring-Boot起步依赖-spring-boot-starter-xxx" class="headerlink" title="Spring Boot起步依赖(spring-boot-starter-xxx)"></a>Spring Boot起步依赖(spring-boot-starter-xxx)</h6><p>Spring Boot提供了很多”开箱即用“的依赖模块，都是以spring-boot-starter-xx作为命名的。通俗的理解，就是<a target="_blank" rel="noopener" href="http://tengj.top/2017/02/26/springboot1/#%E8%B5%B7%E6%AD%A5%E4%BE%9D%E8%B5%96-spring-boot-starter-xx">组装机和台式机的区别</a>。说白了就是Spring Boot通过对常用的依赖进行在一次的封装。例如我们点spring-boot-starter-web时可以看到，其实这个起步依赖集成了常用的web依赖，如下:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Spring Boot的起步依赖说白了就是对常用的依赖进行再一次封装，方便我们引入，简化了 pom.xml 配置，但是更重要的是将依赖的管理交给了 Spring Boot，我们无需关注不同的依赖的不同版本是否存在冲突的问题，Spring Boot 都帮我们考虑好了，我们拿来用即可。</p>
<p>总的来说，Spring Boot的优点有两个:<br>1.无需考虑不同框架的不同版本的冲突问题。<br>2.简化了pom.xml配置。</p>
<h6 id="Spring-Boot-maven插件"><a href="#Spring-Boot-maven插件" class="headerlink" title="Spring Boot maven插件"></a>Spring Boot maven插件</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Spring Boot Maven插件提供了许多方便的<a target="_blank" rel="noopener" href="http://tengj.top/2017/02/26/springboot1/#Spring-Boot-Maven%E6%8F%92%E4%BB%B6">功能</a>：<br>把项目打包成一个可执行的超级JAR（uber-JAR）,包括把应用程序的所有依赖打入JAR文件内，并为JAR添加一个描述文件，其中的内容能让你用java -jar来运行应用程序。<br>搜索public static void main()方法来标记为可运行类。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/05/12/springboot%E7%AE%80%E4%BB%8B/" data-id="clp1yj7ls0007mpwk4lva1uik" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2021-03学习总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/11/2021-03%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" class="article-date">
  <time datetime="2021-05-11T08:22:58.000Z" itemprop="datePublished">2021-05-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/11/2021-03%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">2021-03学习总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><p>tar解压：<br>tar -xvf filename.tar<br>tar -zxvf filename.tar.gz<br>-x: extract files from an archive<br>-v: verbosely list file processed<br>-z: filter the archive throught gzip<br>-f: use archive file or device ARCHIVE</p>
</li>
<li><p>如何修改linux密码？<br>passwd</p>
</li>
<li><p>CREATE USER ‘user’ IDENTIFIED BY ‘123456’:<br>创建用户名为user, 密码为123456的用户 </p>
</li>
<li><p>grant 授予用户权限<br>参考这篇<a target="_blank" rel="noopener" href="https://blog.csdn.net/anzhen0429/article/details/78296814">博客</a><br>mysql&gt; grant all privileges on <em>.</em> to ‘yangxin’@’%’ identified by ‘yangxin123456’ with grant option;<br>all privileges：表示将所有权限授予给用户。也可指定具体的权限，如：SELECT、CREATE、DROP等。<br>on：表示这些权限对哪些数据库和表生效，格式：数据库名.表名，这里写 * 表示所有数据库，所有表。如果我要指定将权限应用到test库的user表中，可以这么写：test.user<br>to：将权限授予哪个用户。格式：“用户名”@“登录IP或域名”。%表示没有限制，在任何主机都可以登录。比如：”yangxin”@”192.168.0.%”，表示yangxin这个用户只能在192.168.0IP段登录<br>identified by：指定用户的登录密码<br>with grant option：表示允许用户将自己的权限授权给其它用户</p>
</li>
<li><p>Mysql查询用户表？<br>SELECT User, Host, Password FROM mysql.user;</p>
</li>
<li><p>echo -n中的-n是什么意思？<br>-n: do not output the trailing newline</p>
</li>
<li><p>Linux下用base64加密解密字符串<br>加密:<br>$echo Hello World | base64<br>SGVsbG8gV29ybGQK</p>
<p>解密:<br>$ echo SGVsbG8gV29ybGQK | base64 -d<br>Hello World</p>
</li>
<li><p>linux终端下的export: export 的效力仅限于该次登陆操作 </p>
</li>
<li><p>开发环境、生产环境和测试环境？<br>项目部署环境一般可分为三种: 生产环境，测试环境，开发环境<br>开发环境：开发环境时程序猿们专门用于开发的服务器，配置可以比较随意，为了开发调试方便，一般打开全部错误报告和测试工具，是最基础的环境。开发环境的分支，一般是feature分支。<br>测试环境：一般是克隆一份生产环境的配置，一个程序在测试环境工作不正常，那么肯定不能把它发布到生产服务器上，是开发环境到生产环境的过度环境。测试环境的分支一般是develop分支，部署到公司私有的服务器或者局域网服务器上，主要用于测试是否存在bug，一般会不让用户和其他人看到，并且测试环境会尽量与生产环境相似。<br>生产环境： 生产环境是指正式提供对外服务的，一般会关掉错误报告，打开错误日志，是最重要的环境。部署分支一般为master分支。<br>三个环境也可以说是系统开发的三个阶段：开发-&gt;测试-&gt;上线，其中生产环境也就是投产说的真实的环境，最后交给用户的环境。</p>
</li>
<li><p>导入maven的project？<br>直接导入project的pom.xml文件</p>
</li>
<li><p>maven中groupID和artifactID分别是什么意思？<br>groupID: 代表组织和整个项目的唯一标志，比如说所有的Maven组件的groupID都是org.apache.maven。<br>artifactID: 具体项目的名称，它与groupID共同确定一个项目在maven repo中的位置，例如，groupId=org.codehaus.mojo, artifactId=my-project的项目，在maven repo中的位置为：$M2_REPO/org/codehaus/mojo/my-project。<br>version: 用于说明目前项目的版本，在引用依赖的时候确定具体依赖的版本号。<br>packaging: 规定项目的输出格式，包括jar、war、pom、apk等，根据实际需要确定。例如，开发一般的java库，可以使用jar packaging；开发android则是apk packaging。</p>
<p>或者这样理解，<br>groupId<br>定义了项目属于哪个组，举个例子，如果你的公司是mycom，有一个项目为myapp，那么groupId就应该是com.mycom.myapp.<br>artifactId<br>定义了当前maven项目在组中唯一的ID,比如，myapp-util,myapp-domain,myapp-web等。<br>version<br>指定了myapp项目的当前版本，SNAPSHOT意为快照，说明该项目还处于开发中，是不稳定的版本。</p>
</li>
<li><p>IDEA maven配置？<br>来源于<a target="_blank" rel="noopener" href="https://www.timbotetsu.com/blog/intellij-ideali-mavende-faq/">博客</a>:<br>Maven home directory: Maven的主目录(就是maven下载的地址: the maven home directory is the one maven is installed to)<br>User settings file：用户设置配置文件<br>Local repository：本地仓库(也就是Jar包)存放路径<br>本地仓库 –&gt; 私服 –&gt; 中央仓库</p>
</li>
<li><p>Mysql是用AUTO_INCREMENT来标识字段的自增<br>PostgreSQL使用序列来标识字段的自增长</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> runoob</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">serial</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    alttext <span class="built_in">text</span>,</span><br><span class="line">    imgurl <span class="built_in">text</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Give all permision to a user on a PostgreSQL database:<br>参考这篇<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/22483555/give-all-permissions-to-a-user-on-a-postgresql-database">stackoverflow</a><br>GRANT ALL PRIVILEGES ON DATABASE “my_db” to my_user;</p>
</li>
<li><p>create database if not exist database_name目前在高斯数据库中不可用实现 </p>
</li>
<li><p>在高斯数据库中create table  table_name(…)中会默认创建在以当前用户为名的schema中，如果没有当前用户为名的schema就会创建在名为public的schema中。</p>
</li>
<li><p>create table tablename优先级: 用户名所在的schema –&gt; 名为public的schema<br>select * from tablename优先级: pg_catalog –&gt; 用户名所在的schema –&gt; 名为public的schema</p>
</li>
<li><p>executeUpdate和executeQuery有什么区别？<br>参考这篇<a target="_blank" rel="noopener" href="https://blog.csdn.net/u012501054/article/details/80323176">blog</a>, executeQuery用于产生ResultSet语句, 例如: 被执行最多的select语句。 这个方法被用来执行查询语句，执行后返回代表查询结果的ResultSet对象。executeUpdate用于执行insert, update或delete语句以及SQL DDL语句，例如CREATE TABLE和DROP TABLE。<br>INSERT、UPDATE或DELETE语句的效果是修改表中零行或多行中的一列或多列。<br>executeUpdate的返回值是一个整数(int)。</p>
</li>
<li><p>什么是两地三中心？<br>两地三中心顾名思义，两个地方，三个中心的意思是：生产中心、同城容灾中心、异地容灾中心。从意义上来看就是，兼具同城容灾和异地容灾，结合起来就叫<a href="https://link.zhihu.com/?target=https://www.idcicp.cn/solution/dr.html">两地三中心</a>。<strong>第一步：同城双中心</strong>，是指在同城或邻近城市建立两个可独立承担关键系统运行的数据中心，双中心具备基本等同的业务处理能力并通过高速链路实时同步数据，日常情况下可同时分担业务及管理系统的运行，并可切换运行；灾难情况下可在基本不丢失数据的情况下进行灾备应急切换，保持业务连续运行。<strong>第二步：异地灾备中心</strong>是指在异地的城市建立一个备份的灾备中心，用于双中心的数据备份，当双中心出现自然灾害等原因而发生故障时，异地灾备中心可以用备份数据进行业务的恢复。<br>和同城双活的区别就是，两地三中心比同城双活多了一个异地数据中心。这个异地数据中心主要用于规避大自然灾害发生时，异地的数据中心能够立即启动，保障业务和数据最大限度不受影响，仍能够正常运行，将企业因大自然灾害受到的损失减到最小。</p>
</li>
<li><p>postgresql中什么是oid?<br>来自这篇<a target="_blank" rel="noopener" href="https://www.postgresql.org/docs/12/datatype-oid.html#DATATYPE-OID-TABLE">文档</a>:<br>Object identifiers (OIDs) are used internally by PostgreSQL as primary keys for various system tables. Type <code>oid</code> represents an object identifier. There are also several alias types for <code>oid</code>: <code>regproc</code>, <code>regprocedure</code>, <code>regoper</code>, <code>regoperator</code>, <code>regclass</code>, <code>regtype</code>, <code>regrole</code>, <code>regnamespace</code>, <code>regconfig</code>, and <code>regdictionary</code>. <a target="_blank" rel="noopener" href="https://www.postgresql.org/docs/12/datatype-oid.html#DATATYPE-OID-TABLE">Table 8.26</a> shows an overview.<br>The <code>oid</code> type is currently implemented as an unsigned four-byte integer(也就是int类型). Therefore, it is not large enough to provide database-wide uniqueness in large databases, or even in large individual tables.</p>
</li>
<li><p>如何查看guassdb中一个视图中所有表的字段属性？<br>来自于这篇<a target="_blank" rel="noopener" href="https://dba.stackexchange.com/questions/29901/query-to-identify-all-data-types-used-in-postgresql-database-tables">stackoverflow</a> </p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> data_type, <span class="keyword">count</span>(*) </span><br><span class="line"><span class="keyword">from</span> information_schema.columns </span><br><span class="line"><span class="keyword">where</span> table_schema = <span class="string">&#x27;public&#x27;</span> </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> data_type ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ps -ef是什么意思？<br>To see every process on the system<br>-f: do format listing<br>-e: select all process<br>ps(process status): report a snapshot of the current status</p>
</li>
<li><p>What is the meaning of instances and schemas of DBs?<br>Instances of DBs: The collection of data stored in the DB at a particular moment is called an instance of the DB<br>Schemas of DBs: The overall design/description of the DB is called the DB schema </p>
</li>
<li><p>Springboot逻辑框架<br>src/main/java 程序开发以主入口<br>src/main/resources 配置文件<br>src/test/java 测试程序<br>Application.java 建议放到根目录下面<br>model目录主要用于实体与数据访问层<br>service层主要是业务类代码<br>controller负责页面访问控制    </p>
</li>
<li><p>@Controller 和 @RestController有什么区别？<br>@Controller is used to mark classes as Spring MVC Controller<br>@RestController is a convenience annotaion that does nothing more than add the @Controller and @ResponseBody annotations </p>
<p>So the following two controller definitions should do the same</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@Responsebody</span></span><br><span class="line"><span class="function">Public class <span class="title">MyController</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="function">Public class <span class="title">MyController</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>@Responsebody是什么？<br>@ResponseBody annotation can be put on a method and indicates that hte return type should be written straight to HTTP response body(and not placed in a Model, or interpreted as a view name)</p>
</li>
<li><p>@ResponseBody和@RestController需要注意的地方:<br>@ResponseBody，一般是使用在单独的方法上的，需要哪个方法返回json数据格式，就在哪个方法上使用，具有针对性。<br>@RestController，一般是使用在类上的，它表示的意思其实就是结合了@Controller和@ResponseBody两个注解。<br>需要注意的是，使用了@RestController注解之后，其本质相当于在该类的所有方法上统一使用了@ResponseBody注解，所以该类下的所有方法都会返回json数据格式。</p>
</li>
<li><p>controller的用法？<br>参照这几篇博客: <a target="_blank" rel="noopener" href="https://blog.mythsman.com/post/5d2b5e9025601931a5f8d877/#:~:text=Controller%E6%98%AFSpringBoot%E9%87%8C%E6%9C%80,%E7%BB%99%E4%B8%8D%E5%90%8C%E7%9A%84%E5%A4%84%E7%90%86%E6%9C%8D%E5%8A%A1%E3%80%82">博客1</a> 和 <a target="_blank" rel="noopener" href="https://blog.csdn.net/zhangpower1993/article/details/81878773">博客2</a><br>处理http请求的，告知spring这是一个控制器<br>Controller是SpringBoot里最基本的组件，他的作用是把用户提交来的请求通过对URL的匹配，分配给不同的接收器，再进行处理，然后向用户返回结果。他的重点就在于如何从HTTP请求中获得信息，提取参数，并分发给不同的处理服务。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/05/11/2021-03%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" data-id="clp1yj7lm0001mpwk001s2nxs" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2021-01学习总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/01/27/2021-01%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" class="article-date">
  <time datetime="2021-01-27T07:27:45.000Z" itemprop="datePublished">2021-01-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/01/27/2021-01%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">2021-01学习总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><p>mkdir -p /data/PostgreSQL 里面的-p是什么意思?<br>From this <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man1/mkdir.1.html">blog</a>: -p: –parents:  no error if existing, make parent directories as needed</p>
</li>
<li><p>查看当前哪一个用户？<br>whoami</p>
</li>
<li><p>su - user 和 su user 有什么区别？<br>su - user切换到某个用户时环境变量也跟着改, su user 切换到某个用户环境变量不变</p>
</li>
<li><p>sudo  su - 是什么意思？<br>The command starts a login shell and you will find yourself in root’s home directory with root’s environment</p>
</li>
<li><p>chown -R postgres:postgres /data/PostgreSQL 是什么意思？<br>Linux chown(#chown user[:group] file)命令用于设置文件所有者和文件管理组的命令<br>其中-R 处理制定用户以及子目录的所有文件</p>
</li>
<li><p>pg_ctl 用于初始化PostgreSQL数据库集群。启动、停止，或者重启PostgreSQL后段服务器，或者显示一个运行着的服务器的状态<br>例: 启动postgresql服务器: pg_ctl -D /data/pgdata/ -l logfile start</p>
</li>
<li><p>PostgreSQL 一些操作<br>列出数据库名 \l<br>列出数据库 \c database_name<br>切换用户 \c - user_name<br>查询所有用户 \du</p>
</li>
<li><p>Postgresql大小写敏感？<br>In PostgreSQL unquoted names are case-sensitive, Thus SELECT * FROM hello and SELECT * FROM HELLO are equivalent.<br>However, quoted names are case-sensitive, SELECT * FROM “hello” is not equivalent to SELECT * FROM HELLO</p>
</li>
<li><p>聚合函数(例如max等)不能用于WHERE子句中, 存在这个限制是因为WHERE子句决定哪些行可以进入聚合状态，因此它必须在聚合函数之前计算</p>
</li>
<li><p>SQL注释操作？<br>单行注释： –<br>多行注释：/* */</p>
</li>
<li><p>一个事务所做的更新在它完成之前对于其他事物是不可见的，而之后的所有更新将同时变得可见.<br> The updates made so far by an open transaction are invisible to other transactions until the transaction completes, whereupon all the updates become visible simultaneously.</p>
</li>
</ol>
<ol start="12">
<li><p>/etc/passwd 文件包含了所有用户账户列表以及每个用户的基本信息<br>Eg: christine:x:501:501:Christine Berenahan:/home/christine:/bin/bash<br>最后一个字段/bin/bash指定了用户使用的shell程序</p>
</li>
<li><p>shell 提示符: ‘#’=root用户(超级管理员)</p>
</li>
<li><p>gsql -r 中的 -r 是什么意思？<br>If the paremeter is set, use libedit</p>
</li>
<li><p>setAutoCommit(True) 和 setAutoCommit(False)有什么区别？<br>默认的话为自动提交, 没执行一个update, delete 或者insert的时候都会自动提交数据库，无法回滚事务。<br>设置connection.setAutoCommit(false), 只有程序调用connection.commit()的时候才将先前执行的各语句一起提交到数据库; 或者先前执行各语句的一部分，然后就失败了，这时程序调用connection.rollBack()。这样就实现了事务数据库的回滚。</p>
</li>
<li><p>Java中的next()和nextLine()有什么区别？<br>1）next()以空格、回车、tab键当作结束, 而nextLine()仅仅以回车当作回车符<br>2）对于字符串头部的风格, next()自动忽略, 直到遇到有效的字符才读取; 而nextLine()会连着空格一块读取</p>
</li>
<li><p>String str = new String(“a”) 和 String str=”a” 有什么区别？<br>1）直接定义的String a = “a”中的”a”是储存在常量区的字符串常量池中。现在在常量池中查找有没有”a”。如果有，就让String a指向那一个，如果没有，就让String a指向在常量池中新建的对象”a”。new String(“a”)就是存储在堆中。<br>2）常量池中相同的字符只会有一个，但是new String()中每new一个对象就会在堆中新建一个对象，不管这个值是否相同。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">String b = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">System.out.println(a==b);</span><br><span class="line">System.out.println(a.equals(b));</span><br><span class="line">System.out.println(str1==str2);</span><br><span class="line">System.out.println(str1.equals(str2));</span><br></pre></td></tr></table></figure>


<ol start="18">
<li>查看内存？<br>cat /proc/meminfo | grep MemTotal 或者 grep MemTotal /proc/meminfo</li>
</ol>
<ol start="19">
<li><p>用户和用户组的概念和关系？<br><strong>A）用户和用户组的概念</strong>:<br>与windows一样, linux下登录系统需要用户和密码, 一般有root超级用户的普通用户的区别, 其中root用户具有最高权限，并可以对普通用户进行秘密管理和权限分配。用户组是将不同用户的公共行为抽象形成一个组，只要是这个组的成员，都可以访问用户组所有的资源。<br><strong>B）用户和用户组的关系</strong>:<br>一个用户对应于一个用户组<br>一个用户可以属于多个用户组，一个用户可以有多个用户<br>在linux下, /etc/passwd, /etc/shadow和/etc/group三个文件保存了用户和用户组的信息<br>创建用户账户是，系统会自动创建用户对应的主目录, 该目录默认放在/home目录下, 若要改变位置，可以利用-d参赛指定。对应用户登录时使用的shell, 默认为/bin/bash, 若要更改，则使用参数-s指定。<br><strong>C）Example</strong>:<br>I）添加组[每个用户都有用户组，系统可以对每个用户进行集中管理]:<br>groupadd -g 1099 postgres<br>II）添加用户:<br>useradd -g postgres -u 1009 -d /home/postgre -m postgres<br>[-g 用户组: 指定用户所属的附加组; -u 用户号:指定用户的用户号; -d 目录: 指定用户主目录, 如果此目录不存在，则使用-m选项, 则可以创建目录]<br>III）设置postgres用户的密码<br>(超级用户可以通过passwd username指定用户的口令)<br>passwd postgres</p>
</li>
<li><p>SUSE zypper 本地源配置<br>1）下载suse镜像文件并上传服务器(例/root)<br>2）创建一个空的目录(例/media)<br>3）执行如下命令进行挂载到本地目录 mount /root/xxxx.iso /media -o loop<br>4）进入/etc/zypp/repos.d 修改配置文件为baseurl=file:///media 或者直接在命令行输入zypper ar file:///media</p>
</li>
<li><p>什么是挂载？mount是用来干什么的？<br>来自这篇<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39521554/article/details/79501714">博客</a><br>1）提一句Windows下，mount挂载，就是给磁盘分区提供一个盘符（C,D,E,…）。比如插入U盘后系统自动分配给了它I:盘符其实就是挂载，退优盘的时候进行安全弹出，其实就是卸载unmount。<br>2）Linux下，不像Windows可以有C,D,E,多个目录，Linux只有一个根目录/。在装系统时，我们分配给linux的所有区都在/下的某个位置，比如/home等等。<br>3）提问者插入了新硬盘，分了新磁盘区sdb1。它现在还不属于/。<br>4）我们虽然可以在一些图形桌面系统里找到他的位置，浏览管理里面的文件，但在命令行却不知怎么访问它的目录，比如无法使用cd或者ls。也无法在编程时指定一个目录对它操作。<br>5）这时提问者使用了 mount /dev/sdb1 ~/Share/ ，把新硬盘的区sdb1挂载到工作目录的~/Share/文件夹下，之后访问这个~/Share/文件夹就相当于访问这个硬盘2的sdb1分区了。对~/Share/的任何操作，都相当于对sdb1里文件的操作。<br>6）所以Linux下，mount挂载的作用，就是<strong>将一个设备（通常是存储设备）挂接到一个已存在的目录上。</strong>访问这个目录就是访问该存储设备。<br>7）<strong>linux操作系统将所有的设备都看作文件，它将整个计算机的资源都整合成一个大的文件目录。</strong>我们要访问存储设备中的文件，必须将文件所在的分区挂载到一个已存在的目录上，然后通过访问这个目录来访问存储设备。挂载就是把设备放在一个目录下，让系统知道怎么管理这个设备里的文件，了解这个存储设备的可读写特性之类的过程。<br>8）我们不是有/dev/sdb1 吗，直接对它操作不就行了？这不是它的目录吗？<br>9）这不是它的目录。虽然/dev是个目录，但/dev/sdb1不是目录。可以发现ls/dev/sdb1无法执行。/dev/sdb1，是一个类似指针的东西，指向这个分区的原始数据块。mount前，系统并不知道这个数据块哪部分数据代表文件，如何对它们操作。<br>10）插入CD，系统其实自动执行了 mount /dev/cdrom /media/cdrom。所以可以直接在/media/cdrom中对CD中的内容进行管理。</p>
</li>
<li><p>mkdir() 和mkdirs()有什么区别？<br>From this <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/9820088/difference-between-mkdir-and-mkdirs-in-java-for-java-io-file">blog</a><br><strong>javadocs for mkdirs()</strong>:<br>Creates the directory named by this abstract pathname, including any necessary but nonexistent parent directories. Note that if this operation fails it may have succeeded in creating some of the necessary parent directories.<br><strong>javadocs for mkdir()</strong>:<br>Creates the directory named by this abstract pathname.<br><strong>Example</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File f = <span class="keyword">new</span> File(<span class="string">&quot;non_existing_dir/someDir&quot;</span>);</span><br><span class="line">System.out.println(f.mkdir());</span><br><span class="line">System.out.println(f.mkdirs());</span><br></pre></td></tr></table></figure>
<p>will yield false for the first [and no dir will be created], and true for the second, and you will have created non_existing_dir/someDir.</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/01/27/2021-01%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" data-id="clp1yj7le0000mpwkfirfbpd8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数据库面试" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/26/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95/" class="article-date">
  <time datetime="2020-10-26T10:11:44.000Z" itemprop="datePublished">2020-10-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/26/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95/">数据库面试</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><p>事务是什么？<br>事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所做的更改都会被撤销。也就是事务具有原子性：一个事务的一系列操作要么全部成功，要么一个都不做。Mysql事务commit之后无法回滚，未commit可以回滚。</p>
</li>
<li><p>数据库ACID的特性？<br>原子性：事务是一个不可分割的工作单位，事务的操作要么都发生，要么都不发生。<br>一致性：事务前后数据的完整性必须保持一致。<br>隔离性：事务前后数据库的完整性保持一致[应用系统从一个正确的状态到另一个正确的状态]<br>隔离性：多个用户并发访问数据库时，一个用户的事务不能被其他用户的事务所干扰，多个并发事务之间要相互隔离。<br>持久性：一个事务一旦提交，它对数据库中数据的改变就是永久性的，即使数据库故障也不应该对其有任何影响。<br>A(Atomicity)原子性、C(Consistency)一致性、I(Isolation)隔离性、D(Durability)持久性</p>
</li>
<li><p>数据库三大范式？<br>第一范式(1NF)：符合1NF的关系中的每个属性都不可再分<br>第二范式(2NF): 第二范式在第一范式的基础上更近一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关(主要针对联合主键而言)<br>第三范式(3NF): 第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。</p>
</li>
<li><p>DDL、DML？<br>DML(Data Manipulation Language)数据库操纵语言。适用范围：对数据库的<strong>数据</strong>进行一些简单操作。如Insert、Delete、Update等。<br>DDL(Data Definition Language)。适用范围: 对数据库中的某些对象(例如database, table)进行管理，如Create、Alter和Drop。<br>区别:<br>1） DML操作是可以手动控制事务的开启，提交和回滚的。<br>2）DDL操作是隐性提交的，不能rollback！</p>
</li>
<li><p>drop、delete和truncate分别在什么场景下使用?<br>1）不再需要一张表的时候用drop<br>2）想删除部分数据行的时候用delete，并且带上where子句<br>3）保留表而删除所有数据用truncate</p>
<table>
<thead>
<tr>
<th align="center">drop table</th>
<th align="center">truncate table</th>
<th align="center">delete from</th>
</tr>
</thead>
<tbody><tr>
<td align="center">属于DDL(故不可回滚)</td>
<td align="center">属于DDL(故不可回滚)</td>
<td align="center">属于DML(故可回滚)</td>
</tr>
<tr>
<td align="center">不可带where</td>
<td align="center">不可带where</td>
<td align="center">可带where</td>
</tr>
<tr>
<td align="center">表内容和结构删除</td>
<td align="center">表内容删除</td>
<td align="center">表结构在，表内容看where执行情况</td>
</tr>
<tr>
<td align="center">删除速度快</td>
<td align="center">删除速度快</td>
<td align="center">删除速度慢，需逐行删除</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="6">
<li><p>什么是视图以及视图的使用场景有哪些？<br>视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增、删、改、查操作。视图通常是一个表或者多个表的行或列的子集。对视图的修改不影响基本表，它使我们获取数据更容易。<br>视图的使用场景:<br>1）只暴露部分字段给访问者，所以就建一个虚表，就是视图。<br>2）查询的数据来源于不同的表，而查询者希望以统一的方式查询，这样也可以建一个视图，把多个查询结构联合起来，查询者只需要从视图中获取数据，不必考虑数据来源于不同表带来的差异。</p>
</li>
<li><p>超键、候选键、主键、外键分别是什么？<br>1）超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以作为超键，多个属性组合在一起也可以作为超键。超键包含候选键和主键。<br>2）候选键：最小超键，即没有冗余元素的超键。<br>3）主键：数据库表中对储存数据对象予以唯一和完整标识的对象或属性的组合。一个数据表中只能有一个主键且主键的取值不能丧失，即不能为空值(NULL)。<br>4）外键：在一个表中存在的另一个表的主键称为此表的外键。</p>
</li>
<li><p>Mysql如何保证事务的四种特性？<br>1）原子性（Atomicity)<br>Mysql数据库事务的所有修改操作（增、删、改）的相反操作都会写入undo log。比如事务执行了一条insert语句，那么undo log就会记录一条相应的delete语句。一旦发生故障，导致事务无法成功提交，系统则会执行undo log中相应的撤销操作，达到事务回滚的目的。<br>2）持久性（Durability)<br>事务的所有修改操作（增、删、改)，数据库会生成一条redo日志记录到redo log。区别于undo log记录SQL语句，redo log记录的是事务对数据库的哪个数据页做了什么修改。<br>redo日志应用场景：数据库系统直接崩溃，需要进行恢复，一般数据库都会按时间点备份的策略，首先将数据库恢复到最近备份的时间点状态，之后读取该时间点的redo log记录，重新执行相应记录，达到恢复目的。<br>3）隔离线（Isolation)<br>通过锁与MVCC（Multi Version Concurrency Control)机制<br>4）一致性（Consistency)<br>在数据库层面上，数据库通过原子性、隔离性、持久性来保证一致性。也就是ACID四大特性之中，C(一致性)是目的，A(原子性)、I(隔离性)、D(持久性)是手段，是为了保证一致性。在应用层面上，通过代码判断数据库是否有效，然后决定回滚还是提交数据。</p>
</li>
<li><p>什么是SQL注入？<br>SQL注入就是通过把SQL命令插入到web表单提交或输入域名或页面请求的字符串，最终达到欺骗服务器恶意执行SQL命令。</p>
</li>
<li><p>索引是什么？有什么作用以及优缺点？<br>索引是对数据库表中一或多个列的值进行排序的结构，是帮助mysql高效获取数据的数据结构。在数据库中，索引允许数据程序迅速地找到表中的数据，而不必扫描整个数据。<br>索引加快数据库的检索速度。</p>
</li>
<li><p>脏读、不可重复读、幻读？<br>脏读：一个事务读取到另外一个事务未提交的数据。未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，即不存在的数据。读到了不一定最终的数据，就是脏读。<br>不可重复读：不可重复读指的是在同一事物内，不同时刻读到的同一批数据可能不一样，可能会受到其他事物的影响，比如其他事物改了这批数据提交。通常针对数据更新(UPDATE)操作。<br>幻读：在一个事务内读到别的事务插入的数据，导致前后读取不一致。</p>
</li>
<li><p>未读取授权、授权读取、可重复读、序列化？<br>未授权读取，也称为读未提交(Read Uncommitted)，在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。(可能发生脏读、不可重复读和幻读问题，一般很少用此隔离级别)<br>授权读取，也称为读已提交(Read Commited)，一个事务只能看到已经提交的数据。(读已提交级别解决了脏读的问题，但可能发生不可重读和幻读）<br>可重复读(Repeatable Read)，可重复读是指在一个事务内，最开始读到的数据和事务结束前任意时刻读到的数据是一致的。(解决了脏读和不可重复读的问题，但可能发生幻读)<br>序列化(Serializable)，提供严格的事务隔离。它要求事务序列化执行，事务只能一个接一个执行，不能并发执行。<br><strong>不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。</strong><br>Mysql默认隔离级别: repeatable-read<br>Oracle默认为:read-committed</p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">读未提交(Read Uncommitted)</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
</tr>
<tr>
<td align="center">读已提交(Read Committed)</td>
<td align="center">No</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
</tr>
<tr>
<td align="center">可重复读(Repeatable Read)</td>
<td align="center">No</td>
<td align="center">No</td>
<td align="center">Yes</td>
</tr>
<tr>
<td align="center">可串行化(Serializable)</td>
<td align="center">No</td>
<td align="center">No</td>
<td align="center">No</td>
</tr>
</tbody></table>
</li>
<li><p>SQL Transaction?（了解即可）<br>1）Every SQL transaction should start with BEGIN TRANSACTION，BEGIN TRAN or BEGIN TRANSACTION trans_name<br>2）Every Transaction in SQL Server must end with either COMMIT or ROLLBACK statements.<br>3）COMMIT TRANSACTION: This statement tells the SQL to save the changes made between the BEGIN and COMMIT<br>4）ROLLBACK TRANSACTION tells the SQL to erase all the changes made between BEGIG and ROLLBACK</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/10/26/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95/" data-id="clp1yj7lt0008mpwk9a4shx1v" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-计算机网络面试" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/" class="article-date">
  <time datetime="2020-10-23T06:02:53.000Z" itemprop="datePublished">2020-10-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/">计算机网络面试</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1: 计算机的五层模型？<br>应用层、传输层、网络层、链路层、物理层  </p>
<p>2: 常用的协议和对应的端口号？<br>域名系统(DNS)—53—UDP/TCP(长度超过512字节使用TCP)<br>文件传送协议(FTP)—21/20—TCP(控制连接21, 数据连接20)<br>动态主机配置协议(DHCP)—67/68—UDP<br>远程登录协议(TELENT)—23—TCP<br>超文本传输协议(HTTP)—80—TCP<br>电子邮件协议:(不是重点)<br>SMTP—25—TCP<br>POP3—110—TCP<br>IMAP—143—TCP<br>TCP支持的主要应用协议: FTP、Telent、SMTP、POP3、HTTP<br>UDP支持的主要应用协议: DNS、DHCP  </p>
<p>3: TCP和UDP的不同之处？<br>UDP(User Datagram Protocol) 是<strong>无连接的, 尽最大可能交付,没有拥塞控制, 支持一对一,一对多,和多对多的交互通信.</strong><br>TCP(Transmission Control Protocol) 是<strong>面向连接的,提供可靠交付,有流量控制,拥塞控制, 每一条TCP连接只能是点对点的</strong><br>[所谓连接,其实就是客服端和服务端的内存里保存一份关于对方的信息,如ip地址,端口号]<br>TCP与UDP的不同之处:<br>TCP面向连接, UDP面向非连接<br>TCP提供可靠的服务(数据传输), UDP无法保证<br>TCP面向字节流, UDP面向报文<br>TCP数据传输慢, UDP数据传输快  </p>
<p>4: HTTP状态码？<br>1xx—信息型, 服务器收到请求, 需要请求者继续操作<br>2xx—成功型, 请求成功收到, 理解并处理<br>3xx—重定向, 需要进一步操作以完成请求<br>4xx—客服端错误, 请求包含语法错误<br>5xx—服务器错误, 服务器在处理请求的过程中错误</p>
<p>100 continue[目前为止请求都很正常]<br>200 OK<br>301 永久性重定向<br>302 临时性重定向<br>404 Not Modified<br>400 请求报文中存在语法错误<br>403 请求被拒绝<br>404 Not Found<br>500 服务器正在执行请求时发生错误<br>503 服务器暂时处于超负载或正在处于停机维护<br>504 未及时从远端服务器获取请求  </p>
<p>5: TCP为什么要三次握手？<br><strong>三次握手的目的: 明确自己和对方的收发能力是正常的</strong><br><strong>第一次握手: 客户端发送网络包, 服务端收到了</strong><br>这样服务端就可以得出结论: 客户端的发送能力, 服务端的接收能力是正常的.<br><strong>第二次握手: 服务端发包,客户端收到了</strong><br>这样客户端就能得出结论: 服务端的接收能力,发送能力是正常的;客户端的接受, 发送能力是正常的. 不过此时服务器不能确认客户端的接受能力是正常的.<br><strong>第三次握手: 客户端发包,服务端收到了</strong><br>这样服务端就能得出结论: 客户端的接收,发送能力正常;服务器自己的发送,接收能力也是正常.</p>
<p>6: TCP三次握手的过程？<br><img src="/2020/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/TCP-three-way-handshake.png" alt="TCP-three-way-handshake"><br><strong>第一次握手(SYNbit=1, Seq=x)</strong><br>客服端发送一个SYN标志位为1的包,指明客户端的初始化序列号x,此时客户端处于SYN_SEND<br><strong>第二次握手(SYNbit=1, Seq=y, ACKbit=1,ACKnum=x+1)</strong><br>服务器发回确认包应答,即SYN标志位和ACK标志位均为1,并且指定了自己的初始化序列号y,同时把客户端的ISN+1作为ACKnum的值, 表示自己已经收到了客户端的SYN报文,此时服务器处于SYN_REVD状态<br><strong>第三次握手(ACKbit=1, ACKnum=y+1)</strong><br>客户端再次发送确认包,SYN标志位为0,ACK标志位为1.同样地把服务器的ISN+1作为ACK的值,表示已经收到了服务器的SYN报文,此时客户端处于ESTABLISHED状态.服务器收到ACK报文之后,也处于ESTABLIEHED状态, 此时,双方已建立起连接.<br><strong>注:SYN:同步序列编号(Synchronized Sequence Number)</strong><br><strong>ISN: Initial Sequence Number</strong></p>
<p>7: ISN(Initial Sequence Number)是固定的吗？<br>三次握手的其中一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候是如何按序列号组装数据.如果ISN是固定的, 攻击者很容易猜出后续的确认号.因此ISN是动态生成的,ISN随时间而变化,因此每个连接具有不同的ISN.</p>
<p>8: 三次握手可以携带数据吗？<br>第三次握手的时候是可以携带数据的,但是第一次,第二次握手是不可以携带数据的.<br>第一次握手不可以携带数据,其中一个简单的原因就是让服务器更容易受到攻击了.而对于第三次的话,此时客户端已经处于ESTABLISHED状态.对于客户端来说,它已经建立连接了,并且也已经知道服务器的接受,发送能力是正常的了,所以携带数据也没啥毛病.</p>
<p>9: 为什么建立连接是三次握手？而关闭连接是四次挥手？<br>建立连接时,服务端在LISTEN状态下,收到建立连接请求的SYN报文后,把SYN和ACK放在一个报文里发送给客户端<br>关闭连接时,服务端在收到对方FIN报文时,仅仅表示客户端不再发送数据了,但是还可以接受数据,已方是否现在关闭发送数据的通道,需要上层应用来决定.</p>
<p>10: 四次挥手的过程<br><img src="/2020/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/TCP-four-way-handshake.png" alt="TCP-four-way-handshake"><br><strong>第一次挥手(FINbit=1, Seq=x)</strong><br>假设客户端想要关闭连接,客户端发送一个FIN标志位置为1的包,表明自己已经没有数据可以发送了,但是仍然可以接受数据.<br><strong>第二次挥手(ACKbit=1, ACKnum=x+1, Seq=y)</strong><br>服务器收到客户端的FIN包, 发送了一个确认包, 表明自己接受到了客户端关闭连接的请求, 但是还没准备关闭连接<br>发送完毕后,服务器进入CLOSE_WAIT状态,客户端收到这个确认包之后进入FIN_WAIT_2状态,等待服务器关闭连接.<br><strong>第三次挥手(FINbit=1, Seq=y, ACKbit=1, ACKnum=x+1)</strong><br>服务端准备好关闭连接时,向客户端发送结束连接的请求,FIN标志位置为1,发送完毕后,服务器进入LAST_ACK状态,等待来自客户端的最后一个ACK<br><strong>第四次挥手</strong><br>客户端接受到来自服务端的关闭请求,发送一个确认包,并进入TIME_WAIT状态,等待可能出现要求重传的ACK包;服务器端接受到这个确认包后,关闭连接,进入close状态;客户端等待某个固定时间(2MSL, 2Maximum Segment Lifetime)之后,没有收到服务器端的ACK,认为服务器已正常关闭连接,于是自己也关闭连接进入CLOSED状态.</p>
<p>11: 客户端接受服务器端的FIN报文后进入TIMED_WAIT状态,此时并不是直接进入CLOSE状态,还需等待一个时间计时器2MSL.为什么？<br>1）保证客户端发送的最后一个ACK报文端能够到达服务端—这个ACK报文端可能丢失,使得处于LAST-ACK状态的服务端收不到对已方发送的FIN+ACK报文端的确认,服务端超时重传FIN+ACK报文段,而客户端在2MSL时间内收到这个重传的FIN+ACK报文段,接着客户端重传一次确认,重新启动2MSL计时器,最后客户端和服务的都进入到closed状态,若客户端在TIMED_WAIT状态下不等待一段时间,而是发送完ACK报文端后立即释放连接,则无法收到服务的重传的FIN+ACK报文段,所以不会再发送一次确认报文段,则服务端无法进入CLOSED状态.<br>2）客户端在发送完最后一个ACK报文段后,再经过2MSL,就可以使本地连接持续的时间内所产生的所有报文端都从网络中消失,使下一个新的连接中不会出现这种旧的连接请求报文段.<br>[注: MSL(Maximum Segment Lifetime)译为”报文最大生成时间”,也就是任何报文网络上存在的最长时间,超过这个时间报文将被丢弃.]</p>
<p>12: TCP的可靠性到底是指什么？<br>1）数据校验: 为了能够检测数据包在传输过程中是否发生了差错, TCP引入了check sum<br>2）序列号与确认机制:<br>TCP实现可靠传输的方式之一,是通过序列号与确认应答.<br>在TCP中,当发送端的数据到达接收主机时,接收端主机会返回一个确认应答消息,表示已收到消息.<br>3）定时重传:<br>由于网络抖动或不稳定等问题造成数据包丢失,在一段的时间段内接收端没有收到该数据包时,会告知发送端重传该数据包.<br>4）三次握手机制:<br>三次握手机制在一定程度上保证了数据的可靠传输, 两端在建立连接时, 通过三次握手机制来确认两端同步知晓连接.<br>5）拥塞控制:<br>防止过多的数据传入网络中造成网络设备或链路的负载,保证了数据稳定、安全、快速的传输.<br>6）流量控制:<br>流量控制是为了控制发送方的速率, 保证接收方来得及接收,避免发送方无脑发送数据,但对方处理不过来,导致触发重传机制,造成网络流量的无端浪费.</p>
<p>13: TCP和UDP的区别和应用场景？<br>1） TCP有三次握手的连接过程; UDP无连接, 适合消息的多播发布,从单个点向多个点传输消息<br>2）TCP利用握手, ACK和重传机制, 提供了可靠的保证; 而UDP可能丢失,不知道到底有没有接收<br>3）TCP利用序列号保证了消息包的顺序交付,到达可能无序,但TCP会排序<br>4）TCP速度比较慢,因为要创建连接,保证消息的可靠性和有序性等,需要做很多额外的事情; UDP更适合对速度比较敏感的应用,比如在线视频媒体,电视广播,多人在线游戏.</p>
<p>14: 什么是流量控制?什么是拥塞控制？<br><strong>流量控制</strong>是为了控制发送方的速率，保证接收方来得及接收。接收方发送的确认报文的窗口字段可以用来控制发送方窗口的大小，从而影响发送方的发送速率。(将窗口字段设置为0，则发送方不能发送数据)<br><strong>TCP拥塞控制</strong>:如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。<br><strong>流量控制是为了让接收方来得及接收</strong><br><strong>而拥塞控制是为了降低整个网络的拥塞程度</strong></p>
<p>15: 拥塞控制？<br>TCP主要通过四个算法来进行拥塞控制: 慢开始,拥塞避免,快重传,快恢复<br>慢开始和快恢复的快慢指的是cwnd(拥塞窗口)的设定值，而不是cwnd的增长速率。慢开始cwnd设定为1，而快恢复cwnd设定为ssthresh<br>具体的可以参考cyc的<a target="_blank" rel="noopener" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E4%BC%A0%E8%BE%93%E5%B1%82.md#tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6">github博客</a></p>
<p>16: 在浏览器中输入URL回车之后会发生什么？<br>1）URL解析<br>2） DNS查询（浏览器查找域名的IP地址）<br>3） TCP连接<br>4）服务器处理请求<br>5） 浏览器接收相应<br>6）渲染页面<br>具体可以参考<a target="_blank" rel="noopener" href="https://juejin.im/post/6844903922084085773">这篇博客</a></p>
<p>17: HTTP和HTTPS有什么区别？<br><strong>HTTP协议</strong>是超文本传输协议的缩写，英文是HyperText Transfer Protocol。它是从WEB服务器传输超文本标记语言（HTML）到本地浏览器的协议。<br><strong>HTTPS协议</strong>(Hypertext Transfer Protocol Secure)是一种透过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。<br>1）HTTP明文传输，数据都是未加密的，安全性较差；HTTPS(SSL+HTTP)数据传输过程是加密的，安全性较好<br>2）HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样。HTTP的端口是80，HTTPS是443<br>3）HTTPS是建构在SSL/TLS之上的HTTP协议，所以HTTPS要比HTTP更耗费服务器资源<br>4）HTTP页面响应速度比HTTPS要快，HTTPS除了三次握手，还要加上握手需要的额外的包。</p>
<p>18: HTTP常见的请求方法？<br>GET: 请求指定的页面信息，并返回实体主体<br>POST: 向指定资源提交数据进行处理请求(例如提交表单或者上传文件)。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改<br>HEAD: 类似于get请求，只不过返回的相应中没有具体的内容，用于获取包头<br>PUT：从客户端向服务器传送的数据取代指定的文档内容<br>DELETE:请求服务器删除指定的页面</p>
<p>19: 什么是对称加密？什么是非对称加密？<br>对称加密: 对称加密算法中的加密和解密用的是同一个密匙<br>非对称加密：一个是保密的，称为私匙；另一个是公开的，称为公匙<br>用私匙加密的数据，只有对应的公匙才能解密。<br>用公匙加密的数据，只有对应的私匙才能解密。<br>公匙是公开的，而私匙是保密的。</p>
<p>20: 转发和重定向的区别？<br><strong>转发: ** 发送在服务器内部的跳转，所以，对客户端来说，至始至终就是一次请求。</strong>所以这期间，保存在request对象的数据可以传递<br>重定向: <strong>发送在客户端的跳转，所以，是多次请求。</strong>这个时候，如果需要在多次请求之间传递数据，需要session对象。<br>重定向：可以理解为客户端行为，客户端发起一次请求，服务端给出一次响应，但这个响应包含下一次客户端需要访问的服务器端处理程序的地址，客户端再次发起请求，将会得到处理结果，也就意味着客户端至少发起两次请求<br>请求转发：服务端行为，客户端发起一次请求，这个请求在服务端可以被多次传递，但都是由服务器端的处理程序传递给另外一个处理程序，客户端不需要发起二次请求，无论这个请求经历过多少个处理程序，始终都是同一个请求。</p>
<p>21: Session和Cookie的区别？<br>Session是在服务端保存的一个数据结构，用来跟踪用户状态。<br>Cookie是客户端保存信息的一种机制，用来记录用户的一些信息。</p>
<p>22: IP地址？A/B/C类地址？子网掩码？<br>IP地址=网络号(表示其属于互联网的哪一个网络)+主机号(表示其属于该网络中的哪一天主机)<br>(全0和全1都保留不用,每一个字节都为0的地址(0.0.0.0)对应当前主机,IP地址中每一个字节都为1的地址(255.255.255.255)是当前子网的广播地址)<br><img src="/2020/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/IP-address.png" alt="IP-address"><br>网络掩码又叫子网掩码,它是一种指明一个IP地址的的哪些标识是主机所在的网络地址以及哪些表示标识是主机地址的位掩码。通俗的说，就是将某个IP地址划分成网络地址和主机地址两部分。</p>
<p>表示方法(了解即可)<br>1）子网掩码的表示方法和地址本身的表示方法是一样的。在IPV4中，就是点分十进制四组表示法(255.128.0.0)<br>2）另一个更简短的形式叫无类别域间路由表示法，它给出的是一个地址和一个斜杠以网络掩码的二进制表示法中”1”的位数。例如，192.0.2.96/28表示的是一个前28位被用作网络号的IP地址。<br>[<strong>注意: 子网掩码二进制中1和0必须是连续的</strong>]</p>
<p>23: ARP是什么？<br>ARP(Address Resolution Protocol)是一个通过解析网络层地址来找寻数据链路层地址的网络传输协议<br>1）首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系<br>2）当源主机要发送数据时，首先检查ARP列表是否有对应IP地址的目的主机的MAC地址，如果有则直接发送数据，如果没有就向本网段的所有主机发送ARP数据包。该数据包包括：源主机IP地址，源主机MAC地址，目的主机IP地址。<br>3）当网络中的所有主机收到该ARP数据包时，首先检查数据包的IP地址是否是自己的IP地址，如果是，则从数据包中取出源主机的IP的和MAC地址写入ARP列表中，如果已存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。<br>4）源主机收到ARP响应包后，将目的主机的IP和MAC地址写向ARP列表，并利用此信息发送数据，如果源主机一直没收到ARP响应数据包，表示ARP查询失败。<br>[广播发送ARP请求，单播发送ARP响应]</p>
<p>24: 域名的级别以及DNS服务器的递归查询和迭代查询？<br>.代表根域名；.com这种是顶级域名，也叫做一级域名；baidu.com这种叫做二级域名<br><img src="/2020/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/DNS_Server.png" alt="DNS-Server"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/" data-id="clp1yj7lu000ampwk3wvk8fy5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-最大公约数和最小公倍数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/01/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/" class="article-date">
  <time datetime="2020-09-01T06:10:02.000Z" itemprop="datePublished">2020-09-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/01/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/">最大公约数和最小公倍数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最大公约数(Greatest Common Divisor)[GCD]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd</span>(<span class="params">a, b</span>):</span></span><br><span class="line">  a, b = (a, b) <span class="keyword">if</span> a&gt;=b <span class="keyword">else</span> (b, a)</span><br><span class="line">  <span class="keyword">while</span> b:</span><br><span class="line">    a, b = b, a%b</span><br><span class="line">  <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>

<p>最小公约数（Least Common Multiple)[LCM]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lcm</span>(<span class="params">a, b</span>):</span></span><br><span class="line">  <span class="keyword">return</span> a*b//gcd(a, b)</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/01/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/" data-id="clp1yj7lt0009mpwk41zmdyys" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Python的一些知识点-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/31/Python%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9-1/" class="article-date">
  <time datetime="2020-08-31T05:32:48.000Z" itemprop="datePublished">2020-08-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/31/Python%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9-1/">Python的一些知识点(1)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>strip() 方法用于移除字符串头尾指定的字符(默认为空格)。<br><strong>注意:该方法只能删除开头或结尾的字符, 不能删除部分中间部分的字符。</strong><br>返回值——返回移除字符串头尾指定的字符序列生成的新字符串。  </p>
<p>split() 通过指定分隔符(默认为所有的空格符, 包括空格、换行、制表符等)对字符串进行切片,如果参数有指定值,则分隔num+1个字符串。<br>返回值——返回分割后的字符串列表。 </p>
<p>slice (start, stop, step)</p>
<table>
<thead>
<tr>
<th align="left">-</th>
<th align="center">-</th>
<th align="center">-</th>
<th align="center">-</th>
<th align="center">-</th>
<th align="center">-</th>
<th align="center">-</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">5</td>
<td align="center">6</td>
</tr>
<tr>
<td align="left">A</td>
<td align="center">S</td>
<td align="center">T</td>
<td align="center">R</td>
<td align="center">I</td>
<td align="center">N</td>
<td align="center">G</td>
</tr>
<tr>
<td align="left">-7</td>
<td align="center">-6</td>
<td align="center">-5</td>
<td align="center">-4</td>
<td align="center">-3</td>
<td align="center">-2</td>
<td align="center">-1</td>
</tr>
</tbody></table>
<p>string.isalnum() 判断所有字符串都是字母或者数字<br>string.isalpha() 判断所有字符都是字母<br>string.isdigit() 判断所有字符都是数字<br>string.islower() 判断所有字符都是小写<br>string.isupper() 判断字符都是大写<br>string.istitle() 所有单词都是首字母大写  </p>
<p>sys.exit() 执行该语句会直接退出程序  </p>
<p>pop(index=-1) 函数用于移除列表中的一个元素(默认为最后一个元素), 并且返回该元素的值。  </p>
<p>如何判断一个数字是整数还是浮点数<br>isinstance(a, int)<br>isinstance(b, float)  </p>
<p>sort() 函数用于对原列表进行排序，如果指定参数，则使用比较函数指定的比较函数<br>list.sort(cmp=None, key=None, reverse=False)<br><strong>返回值——该方法没有返回值，但会对列表的对象进行排序</strong>  </p>
<p>ord() 把字符转成ASCII数值<br>例: ord(‘a’) —&gt; 97<br>chr() 用一个范围在range(256)内(即0～255)的整数作参数，返回一个对应的字符<br>例: chr(97) —&gt; a  </p>
<p><strong>__name __ 是内置变量，用于表示当前模块的名字，当模块被直接运行时模块名为 __main__ 。</strong> 所以 if__name__==’__main__‘的简单理解是，如果模块是被直接运行的，则代码被导入，如果模块是被导入的，则代码块不运行。</p>
<p>reverse()函数用于反向列表中的元素<br>语法: list.reverse()<br>参数: NA<br><strong>返回值: 该方法无返回值，但是会对列表中的元素进行反向排序</strong></p>
<p>Difference between input() and sys.stdin.readline() (from <a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/difference-between-input-and-sys-stdin-readline/">GeeksforGeeks</a> )</p>
<table>
<thead>
<tr>
<th align="center">INPUT()</th>
<th align="center">SYS.STDIN.READLINE()</th>
</tr>
</thead>
<tbody><tr>
<td align="center">The input() takes input from the user but does not read escape character</td>
<td align="center">The readline() also takes input from the user but also reads the escape character</td>
</tr>
<tr>
<td align="center">It has a prompt that represents the default value before the user input</td>
<td align="center">readline() has a arameter named size, which is a non-negative number. It defines the bytes to be read</td>
</tr>
</tbody></table>
<p>zip()函数用于将可迭代的对象作为参数，将对象中大的元素打包成一个个元组，然后返回由这些元组组成的<strong>对象</strong><br>我们可以使用list()转换来输出列表<br>例:<br>a = [1, 2, 3]<br>b = [4, 5, 6]<br>list(zip(a, b))<br>&gt;&gt; [(1, 4), (2, 5), (3, 6)]</p>
<p>Check if a given key alaready  exists in a dictionary:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="string">&#x27;key1&#x27;</span> <span class="keyword">in</span> dict.keys():</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>


<p>Check if a value exists in a dictionary:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="string">&#x27;value1&#x27;</span> <span class="keyword">in</span> dict.values():</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>How to sort a dictionary by its value:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;k:v <span class="keyword">for</span> k, v <span class="keyword">in</span> sorted(x.item(), key=<span class="keyword">lambda</span> item: item[<span class="number">1</span>])&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Note: <del>sorted(d.items(), key=lambda x:x[1], reverse=True)</del> (This will return a list not a dictionary)</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/31/Python%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9-1/" data-id="clp1yj7lr0005mpwkh15p71hx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-About-hexo" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/31/About-hexo/" class="article-date">
  <time datetime="2020-08-31T04:04:04.000Z" itemprop="datePublished">2020-08-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/31/About-hexo/">About hexo</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>hexo clean: 执行 hexo clean 时, Hexo会清除缓存文件 (db.json) 和已生成的静态文件 (public);<br>hexo generate: 执行 hexo generate时, Hexo会在 public 目录下生成网站静态文件;<br>hexo deploy: 执行 hexo deploy 时，Hexo 会将 public 目录中的文件和目录推送至 _config.yml中指定的远端仓库和分支中，并且完全覆盖该分支下的已有内容.   <br>   </p>
<h6 id="Example-How-do-I-delete-a-post-in-hexo-from-stack-overflow"><a href="#Example-How-do-I-delete-a-post-in-hexo-from-stack-overflow" class="headerlink" title="Example: How do I delete a post in hexo (from stack overflow)."></a>Example: How do I delete a post in hexo (from <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/27894210/how-do-i-delete-a-post-in-hexo">stack overflow</a>).</h6><ol>
<li>Delete the post under source/_post folder</li>
<li>Run hexo clean to delete the database (db.json) and assets folder</li>
<li>Run hexo generateto generate the new blog without your deleted post</li>
<li>Run hexo deploy to deploy your blog</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/31/About-hexo/" data-id="clp1yj7lp0003mpwk0bqf7kxg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/11/16/Mock%E5%AD%A6%E4%B9%A0/">Mock学习</a>
          </li>
        
          <li>
            <a href="/2023/10/13/2023-10-13%E6%80%BB%E7%BB%93/">2023-10-13总结</a>
          </li>
        
          <li>
            <a href="/2021/05/12/springboot%E7%AE%80%E4%BB%8B/">springboot简介</a>
          </li>
        
          <li>
            <a href="/2021/05/11/2021-03%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">2021-03学习总结</a>
          </li>
        
          <li>
            <a href="/2021/01/27/2021-01%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">2021-01学习总结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>